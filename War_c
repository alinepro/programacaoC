#include <stdio.h>    // Entrada e sa√≠da de dados
#include <stdlib.h>   // calloc, free, rand, srand
#include <string.h>   // Manipula√ß√£o de strings
#include <time.h>     // time() para semente do rand

#define QTD_TERRITORIOS 5   // Quantidade fixa de territ√≥rios
#define TAM 50              // Tamanho m√°ximo das strings

/* =========================================================
   üß© N√çVEL NOVATO ‚Äì ESTRUTURA E EXIBI√á√ÉO DOS TERRIT√ìRIOS
   ========================================================= */

/* Estrutura que representa um territ√≥rio do jogo */
typedef struct {
    char nome[TAM];   // Nome do territ√≥rio
    char cor[TAM];    // Cor do ex√©rcito dominante
    int tropas;       // Quantidade de tropas
} Territorio;

/* Fun√ß√£o que exibe o estado atual do mapa */
void exibirMapa(Territorio *t) {

    printf("\nüìç ESTADO ATUAL DO MAPA üìç\n");

    // Percorre todos os territ√≥rios e exibe seus dados
    for (int i = 0; i < QTD_TERRITORIOS; i++) {
        printf("Territ√≥rio %d\n", i + 1);
        printf("Nome: %s", t[i].nome);
        printf("Cor do Ex√©rcito: %s", t[i].cor);
        printf("Tropas: %d\n\n", t[i].tropas);
    }
}

/* =========================================================
   üßó‚Äç‚ôÇÔ∏è N√çVEL AVENTUREIRO ‚Äì BATALHAS E ALOCA√á√ÉO DIN√ÇMICA
   ========================================================= */

/* Fun√ß√£o que simula uma batalha entre dois territ√≥rios */
void atacar(Territorio *t, int atk, int def) {

    // Sorteia valores aleat√≥rios entre 1 e 6
    int dadoAtk = rand() % 6 + 1;
    int dadoDef = rand() % 6 + 1;

    printf("\n‚öîÔ∏è BATALHA ‚öîÔ∏è\n");
    printf("Atacante (%s) rolou: %d\n", t[atk].nome, dadoAtk);
    printf("Defensor (%s) rolou: %d\n", t[def].nome, dadoDef);

    // Empate favorece o atacante
    if (dadoAtk >= dadoDef) {

        // Defensor perde uma tropa
        t[def].tropas--;
        printf("‚û°Ô∏è Atacante venceu! Defensor perde 1 tropa.\n");

        // Se o defensor ficar sem tropas, o territ√≥rio √© conquistado
        if (t[def].tropas <= 0) {
            printf("üè≥Ô∏è Territ√≥rio conquistado!\n");

            // A cor do territ√≥rio passa a ser a do atacante
            strcpy(t[def].cor, t[atk].cor);

            // Territ√≥rio conquistado inicia com 1 tropa
            t[def].tropas = 1;
        }

    } else {
        // Caso o defensor ven√ßa
        printf("üõ°Ô∏è Defensor resistiu ao ataque.\n");
    }
}

/* =========================================================
   üß† N√çVEL MESTRE ‚Äì MISS√ïES E MODULARIZA√á√ÉO TOTAL
   ========================================================= */

/* Enumera√ß√£o para representar os tipos de miss√£o */
typedef enum {
    MISSAO_VERDE = 1,
    MISSAO_CONQUISTA = 2
} Missao;

/* Fun√ß√£o que inicializa automaticamente os territ√≥rios */
void inicializarTerritorios(Territorio *t) {

    const char *nomes[] = {
        "Floresta Sombria",
        "Deserto Escarlate",
        "Ilhas do Norte",
        "Plan√≠cie Central",
        "Montanha Negra"
    };

    const char *cores[] = {
        "Verde",
        "Azul",
        "Vermelho",
        "Amarelo",
        "Verde"
    };

    // Inicializa cada territ√≥rio com nome, cor e tropas
    for (int i = 0; i < QTD_TERRITORIOS; i++) {
        strcpy(t[i].nome, nomes[i]);
        strcat(t[i].nome, "\n");

        strcpy(t[i].cor, cores[i]);
        strcat(t[i].cor, "\n");

        t[i].tropas = 3;
    }
}

/* Fun√ß√£o que sorteia uma miss√£o aleat√≥ria */
Missao sortearMissao() {
    return (rand() % 2) + 1;
}

/* Fun√ß√£o que verifica se a miss√£o foi cumprida */
int verificarMissao(const Territorio *t, Missao m) {

    int contador;

    // Miss√£o 1: Destruir o ex√©rcito Verde
    if (m == MISSAO_VERDE) {
        for (int i = 0; i < QTD_TERRITORIOS; i++) {
            if (strstr(t[i].cor, "Verde") != NULL) {
                return 0; // Ainda existe ex√©rcito verde
            }
        }
        return 1; // Miss√£o cumprida
    }

    // Miss√£o 2: Conquistar 3 territ√≥rios da mesma cor
    if (m == MISSAO_CONQUISTA) {
        for (int i = 0; i < QTD_TERRITORIOS; i++) {
            contador = 0;
            for (int j = 0; j < QTD_TERRITORIOS; j++) {
                if (strcmp(t[i].cor, t[j].cor) == 0) {
                    contador++;
                }
            }
            if (contador >= 3) {
                return 1; // Miss√£o cumprida
            }
        }
    }

    return 0; // Miss√£o n√£o cumprida
}

/* Fun√ß√£o que exibe o menu principal */
void menu() {
    printf("\nüéÆ MENU PRINCIPAL üéÆ\n");
    printf("1 - Atacar\n");
    printf("2 - Verificar Miss√£o\n");
    printf("0 - Sair\n");
    printf("Escolha uma op√ß√£o: ");
}

/* =========================================================
   üöÄ FUN√á√ÉO PRINCIPAL
   ========================================================= */

int main() {

    // Ponteiro para os territ√≥rios alocados dinamicamente
    Territorio *territorios;

    // Aloca√ß√£o din√¢mica de mem√≥ria com calloc
    territorios = (Territorio *) calloc(QTD_TERRITORIOS, sizeof(Territorio));

    // Verifica erro de aloca√ß√£o
    if (territorios == NULL) {
        printf("Erro de aloca√ß√£o de mem√≥ria.\n");
        return 1;
    }

    // Inicializa o gerador de n√∫meros aleat√≥rios
    srand(time(NULL));

    // Inicializa√ß√£o autom√°tica dos territ√≥rios
    inicializarTerritorios(territorios);

    // Sorteio da miss√£o
    Missao missao = sortearMissao();

    printf("\nüéØ MISS√ÉO SORTEADA üéØ\n");
    if (missao == MISSAO_VERDE)
        printf("‚û°Ô∏è Destruir o ex√©rcito Verde\n");
    else
        printf("‚û°Ô∏è Conquistar 3 territ√≥rios\n");

    exibirMapa(territorios);

    int opcao, atacante, defensor;

    // Loop principal do jogo
    do {
        menu();
        scanf("%d", &opcao);
        getchar(); // Limpa buffer

        switch (opcao) {

            case 1:
                printf("Territ√≥rio ATACANTE (1 a 5): ");
                scanf("%d", &atacante);

                printf("Territ√≥rio DEFENSOR (1 a 5): ");
                scanf("%d", &defensor);
                getchar();

                if (atacante >= 1 && atacante <= 5 &&
                    defensor >= 1 && defensor <= 5 &&
                    atacante != defensor) {

                    atacar(territorios, atacante - 1, defensor - 1);
                } else {
                    printf("‚ùå Escolha inv√°lida.\n");
                }

                exibirMapa(territorios);
                break;

            case 2:
                if (verificarMissao(territorios, missao)) {
                    printf("\nüèÜ MISS√ÉO CONCLU√çDA COM SUCESSO! üèÜ\n");
                    opcao = 0; // Encerra o jogo
                } else {
                    printf("\n‚è≥ Miss√£o ainda n√£o conclu√≠da.\n");
                }
                break;

            case 0:
                printf("Encerrando o jogo...\n");
                break;

            default:
                printf("Op√ß√£o inv√°lida.\n");
        }

    } while (opcao != 0);

    // Libera√ß√£o da mem√≥ria alocada
    free(territorios);

    return 0;
}
